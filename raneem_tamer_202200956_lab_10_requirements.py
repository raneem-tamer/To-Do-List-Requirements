# -*- coding: utf-8 -*-
"""Raneem Tamer 202200956 Lab 10 Colab practice and requirements.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hBCYzySN3nzYB2ouw_gGtgS18Qi_qYzf

# LAB 10 : UNIT TESTING


---

In this lab, we will learn the core concepts of Unit Testing in software development. The purpose of Unit Testing is to validate that individual units of source code, such as functions, methods, or classes, work as intended. Unit testing ensures that small, isolated components of a program behave correctly under different scenarios. Writing unit tests helps developers catch bugs early in the development cycle and maintain code reliability.

**What is a Unit ?**

A unit refers to the smallest testable part of an application. This could be a function, method, or class that performs a specific task. The goal of unit testing is to ensure that each unit works in isolation without depending on other parts of the program.

**Assertions in Unit Testing**

Assertions are conditions or boolean expressions that evaluate whether the output of a unit matches the expected result.



# ."""



"""# Requirement

## 1. Write Unit Tests from Scratch

###Function 1: multiply_numbers(a, b)

Write a function that multiplies two numbers and test for:

Two positive numbers.

Multiplication with zero.

Negative numbers.
"""

import unittest

def multiply_numbers(a, b):
    return a * b

class TestMultiplyNumbers(unittest.TestCase):
    def test_multiply_two_positive_numbers(self):
        self.assertEqual(multiply_numbers(3, 5), 15)

    def test_multiply_with_zero(self):
        self.assertEqual(multiply_numbers(0, 5), 0)
        self.assertEqual(multiply_numbers(5, 0), 0)
        self.assertEqual(multiply_numbers(0, 0), 0)

    def test_multiply_negative_numbers(self):
        self.assertEqual(multiply_numbers(-3, -5), 15)
        self.assertEqual(multiply_numbers(-3, 5), -15)
        self.assertEqual(multiply_numbers(3, -5), -15)


if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)

"""###Function 2: reverse_list(input_list)

Write a function that reverses a given list and test for:

A normal list.

An empty list.

A single-element list.


"""

import unittest

# function to reverse a list
def reverse_list(input_list):
    return input_list[::-1]


# test class for the reverse_list function
class TestReverseList(unittest.TestCase):

    def test_normal_list(self):
        self.assertEqual(reverse_list([1, 2, 3, 4]), [4, 3, 2, 1])
        self.assertEqual(reverse_list(['R', 'T', 'A']), ['A', 'T', 'R'])

    def test_empty_list(self):
        self.assertEqual(reverse_list([]), [])

    def test_single_element_list(self):
        self.assertEqual(reverse_list([42]), [42])
        self.assertEqual(reverse_list(['only']), ['only'])

# Run the tests
if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)

"""##2. Extend Provided Code

Function 3: calculate_discount(price, discount_percentage)

Extend the function by:

Adding a test for valid inputs (e.g., price = 100, discount = 10%).

Testing invalid discounts (negative or greater than 100%).

Handling zero price or zero discount.


"""

# Import unittest for testing
import unittest


#  function to calculate discount
def calculate_discount(price, discount_percentage):
    if price < 0:
        raise ValueError("Price cannot be negative.")
    if discount_percentage < 0 or discount_percentage > 100:
        raise ValueError("Discount percentage must be between 0 and 100.")

    discount_amount = price * (discount_percentage / 100)
    return price - discount_amount


#  test class for the calculate_discount function
class TestCalculateDiscount(unittest.TestCase):

    def test_valid_inputs(self):
        self.assertEqual(calculate_discount(100, 10), 90)  # 10% off $100
        self.assertEqual(calculate_discount(200, 20), 160)  # 20% off $200
        self.assertEqual(calculate_discount(50, 0), 50)     # 0% off $50

    def test_zero_price(self):
        self.assertEqual(calculate_discount(0, 10), 0)      # 10% off $0
        self.assertEqual(calculate_discount(0, 0), 0)       # 0% off $0

    def test_invalid_discount(self):
        with self.assertRaises(ValueError):
            calculate_discount(100, -10)  # Negative discount
        with self.assertRaises(ValueError):
            calculate_discount(100, 110)  # Discount greater than 100%

    def test_negative_price(self):
        with self.assertRaises(ValueError):
            calculate_discount(-50, 10)    # Negative price should raise an error


if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)

"""##3. Encapsulate in a Class


Class: MathOperations

Implement a class MathOperations that contains:

Method 1: is_prime(n)

Check if a number is prime.

Test cases:

Prime numbers.

Non-prime numbers.

Edge cases like 0, 1, and negative numbers.

Method 2: factorial(n)

Compute the factorial of a number.

Test cases:

Positive integers.

Edge case: n = 0 (factorial is 1).

Invalid cases: negative numbers.
"""

import unittest
# MathOperations class
class MathOperations:
    @staticmethod
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    @staticmethod
    def factorial(n):
        if n < 0:
            raise ValueError("Factorial is not defined for negative numbers.")
        if n == 0:
            return 1
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result


# test class for MathOperations
class TestMathOperations(unittest.TestCase):

    def test_is_prime(self):
        # Test prime numbers
        self.assertTrue(MathOperations.is_prime(2))
        self.assertTrue(MathOperations.is_prime(3))
        self.assertTrue(MathOperations.is_prime(5))
        self.assertTrue(MathOperations.is_prime(13))

        # Test non-prime numbers
        self.assertFalse(MathOperations.is_prime(4))
        self.assertFalse(MathOperations.is_prime(9))
        self.assertFalse(MathOperations.is_prime(15))

        # Test edge cases
        self.assertFalse(MathOperations.is_prime(0))
        self.assertFalse(MathOperations.is_prime(1))
        self.assertFalse(MathOperations.is_prime(-7))

    def test_factorial(self):
        # Test positive integers
        self.assertEqual(MathOperations.factorial(5), 120)
        self.assertEqual(MathOperations.factorial(3), 6)

        # Test edge case: factorial of 0
        self.assertEqual(MathOperations.factorial(0), 1)

        # Test invalid cases: negative numbers
        with self.assertRaises(ValueError):
            MathOperations.factorial(-1)

# Step 4: Run the tests if this script is executed
if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)